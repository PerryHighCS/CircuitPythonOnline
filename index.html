<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CPX WebSerial Console</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    textarea, pre, input, button {
      width: 100%;
      margin-top: 0.5rem;
      font-family: monospace;
      opacity: 1;
      transition: opacity 0.2s ease;
    }
    textarea { height: 200px; }
    pre { height: 200px; overflow-y: auto; background: #f0f0f0; padding: 1rem; }
    #file-list {
      font-size: 0.9rem;
      background: #e8e8e8;
      padding: 0.5rem;
      margin-top: 1rem;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  
    #status-bar { background: #eef; padding: 0.5rem; margin-top: 1rem; font-size: 0.9rem; }
    #status-bar::before { content: "Status: "; font-weight: bold; }  
  </style>
</head>
<body>
  <button id="connect">Connect to Circuit Playground</button>
  <br>
  <label for="filename">Filename:</label>
  <input type="text" id="filename" value="student_code.py">
  <label for="code">Student Code:</label>
  <textarea id="code">import board, neopixel
pixels = neopixel.NeoPixel(board.NEOPIXEL, 10)
pixels.fill((0, 0, 255))</textarea>
  <button id="upload" disabled>Upload File</button>
  <button id="run" disabled>Run File</button>
  <div id="status-bar">Disconnected</div>
  <h3>Device Output:</h3>
  <pre id="output"></pre>

  <h3>Files on Device (Experimental)</h3>
  <button id="list-files" disabled>List Files</button>
  <pre id="file-list"></pre>


  <script>
    const CTRL_A = 0x01; // Enter raw REPL
    const CTRL_B = 0x02; // Exit raw REPL
    const CTRL_C = 0x03; // Break
    const CTRL_D = 0x04; // Execute
    
    let port, writer, reader;
    let outputBuffer = "";

    async function connectSerial() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        const decoder = new TextDecoderStream();
        port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();

        writer = port.writable.getWriter();

        readLoop();
        setStatus("Connected")
      } catch (e) {
        setStatus("Error: " + e)
      }
    }

    async function monitorPortDisconnect() {
      try {
        while (port.readable && port.readable.locked) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        setStatus("Device disconnected. Attempting to reconnect...");
        if (reader) {
          try {
            reader.cancel();
            await reader.releaseLock();
          } catch (e) {
            console.warn("Failed to release reader:", e);
          }
        }
        if (writer) {
          try {
            await writer.releaseLock();
          } catch (e) {
            console.warn("Failed to release writer:", e);
          }
        }
        await port.close();
        await reconnectLoop();
      } catch (e) {
        setStatus("Auto-reconnect failed: " + e);
      }
    }

    async function reconnectLoop() {
      while (true) {
        try {
          const ports = await navigator.serial.getPorts();
          if (ports.length > 0) {
            port = ports[0];
            await port.open({ baudRate: 115200 });

            const decoder = new TextDecoderStream();
            port.readable.pipeTo(decoder.writable);
            reader = decoder.readable.getReader();
            writer = port.writable.getWriter();

            outputBuffer = "";
            readLoop();

            await new Promise(r => setTimeout(r, 500));
            await ensureREPL();

            setStatus("Reconnected to device");
            
            break;
          }
        } catch (e) {
          setStatus("Waiting to reconnect...");
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    async function readLoop() {
      while (true) {
        try {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            outputBuffer += value;
            log(value);
          }
        } catch (e) {
          setStatus("Read error: " + e);
          if (e instanceof DOMException && e.name === "NetworkError") {
            monitorPortDisconnect();
          }
          break;
        }
      }
    }

    function log(msg) {
      const output = document.getElementById("output");
      output.textContent += msg;
      output.scrollTop = output.scrollHeight;
    }

    function setStatus(message) {
  const uploadBtn = document.getElementById("upload");
  const runBtn = document.getElementById("run");
  const listBtn = document.getElementById("list-files");

  if (message.startsWith("Connected") || message.startsWith("Reconnected")) {
    uploadBtn.disabled = false;
    runBtn.disabled = false;
    listBtn.disabled = false;
  } else if (message.startsWith("Disconnected") || message.includes("failed") || message.includes("Waiting")) {
    uploadBtn.disabled = true;
    runBtn.disabled = true;
    listBtn.disabled = true;
  }

      const status = document.getElementById("status-bar");
      status.textContent = message;
    }

    async function send(data) {
      const encoded = new TextEncoder().encode(data);
      await writer.write(encoded);
    }

    async function sendControlByte(byte) {
      await writer.write(new Uint8Array([byte]));
    }

    async function checkForPrompt(timeoutMs = 300) {
      return await new Promise(resolve => {
        const start = Date.now();
        const interval = setInterval(() => {
          if (outputBuffer.includes(">>>")) {
            clearInterval(interval);
            resolve(true);
          } else if (Date.now() - start > timeoutMs) {
            clearInterval(interval);
            resolve(false);
          }
        }, 25);
      });
    }

    async function ensureREPL() {
      for (let attempt = 0; attempt < 3; attempt++) {
        outputBuffer = ""; // Clear buffer before each attempt

        setStatus(`Checking for REPL prompt (attempt ${attempt + 1})...\n`);
        await send("\r\n");
        await new Promise(r => setTimeout(r, 100));
        const hasPrompt = await checkForPrompt();
        if (hasPrompt) return true;

        setStatus("Prompt not found, sending Ctrl-C...\n");
        await sendControlByte(CTRL_C); // Break
        await new Promise(r => setTimeout(r, 100));
        const afterCtrlCPrompt = await checkForPrompt();
        if (afterCtrlCPrompt) return true;
      }

      setStatus("REPL prompt not detected after multiple attempts.\n");
      return false;
    }

    async function uploadFile() {
      if (!await ensureREPL()) {
        setStatus("Failed to get REPL prompt")
        return;
      };

      const filename = document.getElementById("filename").value.trim();
      const code = document.getElementById("code").value;

      if (!filename) {
        setStatus("Filename required")
        return;
      }

      const uploadScript = `
import sys
with open("${filename}", "w") as f:
    while True:
        line = sys.stdin.readline()
        if line.strip() == "<<<END>>>":
            break
        f.write(line)
`;

      await sendControlByte(CTRL_A); // Ctrl-A (raw REPL)
      await new Promise(r => setTimeout(r, 100));
      await send(uploadScript);
      await sendControlByte(CTRL_D); // Ctrl-D (execute)
      await new Promise(r => setTimeout(r, 100));

      const lines = code.split("\n");
      for (let line of lines) {
        await send(line + "\n");
      }
      await send("<<<END>>>\n");
      await sendControlByte(CTRL_B); // Ctrl-B (exit raw REPL)
      setStatus("File uploaded successfully.\n");
    }

    async function runFile() {
      if (!await ensureREPL()) {
        setStatus("Failed to get REPL prompt")
        return;
      };

      const filename = document.getElementById("filename").value.trim();
      if (!filename) {
        setStatus("Filename cannot be empty.\n");
        return;
      }
      setStatus(`Running file: ${filename}\n`);
      await send(`exec(open("${filename}").read())\r\n`);

      // Wait for program to finish by checking for REPL prompt
      const completed = await checkForPrompt(2000);
      if (completed) {
        setStatus("Program finished");
      } else {
        setStatus("Program still running or no prompt detected");
      }
    }


    async function listFiles() {
      document.getElementById("file-list").textContent = "";
      await ensureREPL();
      await send("import os\r\nprint(os.listdir())\r\n");
    }

    document.getElementById("connect").addEventListener("click", connectSerial);
    document.getElementById("upload").addEventListener("click", uploadFile);
    document.getElementById("run").addEventListener("click", runFile);
    document.getElementById("list-files").addEventListener("click", listFiles);
  </script>
</body>
</html>
